/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Graph.ts":
/*!**********************!*\
  !*** ./src/Graph.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Graph = void 0;\r\nconst State_1 = __webpack_require__(/*! ./State */ \"./src/State.ts\");\r\n// Klasse für ungerichtete Graphen\r\nclass Graph {\r\n    constructor() {\r\n        this.AdjList = new Map();\r\n        this.col = new Map();\r\n        this.pi = new Map();\r\n        this.d = new Map();\r\n        this.f = new Map();\r\n        this.l = new Map();\r\n        this.time = 0;\r\n        this.keller = [];\r\n        this.components = [];\r\n        this.circle = [];\r\n        this.done = false;\r\n        this.back_edges = [];\r\n        this.edge = [];\r\n        this.isCircle = false;\r\n        this.bfs_animation = [];\r\n        this.circle_animation = [];\r\n    }\r\n    addVertex(v) {\r\n        // initalize empty adjacency list\r\n        this.AdjList.set(v, []);\r\n    }\r\n    addEdge(src, dest) {\r\n        var _a, _b;\r\n        // edge from src to dest and dest to src\r\n        if (this.AdjList.get(src) !== undefined) {\r\n            (_a = this.AdjList.get(src)) === null || _a === void 0 ? void 0 : _a.push(dest);\r\n            (_b = this.AdjList.get(dest)) === null || _b === void 0 ? void 0 : _b.push(src);\r\n        }\r\n    }\r\n    getGraphD3() {\r\n        var visited_nodes = [];\r\n        var nodes = [];\r\n        for (const v of this.AdjList.keys()) {\r\n            nodes.push({ name: v, color: this.col.get(v) });\r\n        }\r\n        var edges = [];\r\n        for (const v of this.AdjList.keys()) {\r\n            var v_index = this.circle.indexOf(v);\r\n            for (const u of this.AdjList.get(v)) {\r\n                if (visited_nodes.indexOf(u) != -1)\r\n                    continue;\r\n                const u_index = this.circle.indexOf(u);\r\n                if (v_index != -1 &&\r\n                    u_index != -1 &&\r\n                    (u_index - 1 == v_index || u_index + 1 == v_index ||\r\n                        (v_index != this.circle.lastIndexOf(v)) || u_index != this.circle.lastIndexOf(u))) {\r\n                    edges.push({ source: v, target: u, color: State_1.State.circle });\r\n                }\r\n                else\r\n                    edges.push({ source: v, target: u, color: \"black\" });\r\n            }\r\n            visited_nodes.push(v);\r\n        }\r\n        return { nodes: nodes, links: edges };\r\n    }\r\n    setNodeColor(v) {\r\n        this.col.set(v, \"red\");\r\n    }\r\n    checkIfCirlce(circle) {\r\n        // Alle Kanten auf schwarz setzen\r\n        for (const v of this.AdjList.keys()) {\r\n            this.col.set(v, State_1.State.black);\r\n        }\r\n        // Alle Kanten des Kreises weiß setzen\r\n        for (const v of circle) {\r\n            this.col.set(v, State_1.State.white);\r\n        }\r\n        // noch kein Kreis gefunden\r\n        this.isCircle = false;\r\n        for (const v of circle) {\r\n            this.circle_dfs(v, new Set());\r\n        }\r\n    }\r\n    circle_dfs(v, current_circle) {\r\n        // Kein Kreis gefunden\r\n        if (this.col.get(v) == State_1.State.black) {\r\n        }\r\n        else {\r\n            // Kreis gefunden\r\n            if (this.col.get(v) == State_1.State.grey) {\r\n                if (this.eqSet(current_circle, new Set(this.circle)))\r\n                    this.isCircle = true;\r\n                return true;\r\n            }\r\n            // Setze Farbe auf grau\r\n            this.col.set(v, State_1.State.grey);\r\n            for (var u of this.AdjList.get(v)) {\r\n                this.circle_dfs(u, current_circle.add(v));\r\n                this.col.set(v, State_1.State.black);\r\n            }\r\n        }\r\n    }\r\n    eqSet(xs, ys) {\r\n        return xs.size === ys.size && [...xs].every((x) => ys.has(x));\r\n    }\r\n    printGraph() {\r\n        // list of all vertices\r\n        var vertices = this.AdjList.keys();\r\n        for (var i of vertices) {\r\n            var vertice_list = this.AdjList.get(i);\r\n            var output = \"\";\r\n            if (vertice_list) {\r\n                for (var j of vertice_list) {\r\n                    output += j + \" \";\r\n                }\r\n                console.log(i + \" -> \" + output);\r\n            }\r\n            else {\r\n                console.log(\"Vertice \" + i + \"had not been initialized yet.\");\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Diese Methode initialisiert und führt die Breitensuche durch.\r\n     * @param s Startknoten\r\n     */\r\n    bfs(s) {\r\n        // 1. Initialisierung\r\n        for (var u of this.AdjList.keys()) {\r\n            this.col.set(u, State_1.State.white);\r\n            this.pi.set(u, null);\r\n        }\r\n        this.bfs_animation.push(this.getGraphD3());\r\n        // 2. Breitensuche mit Warteschlange\r\n        this.col.set(s, State_1.State.grey);\r\n        var Q = [];\r\n        Q.push(s);\r\n        this.bfs_animation.push(this.getGraphD3());\r\n        while (Q.length != 0) {\r\n            var u = Q[0];\r\n            for (const v of this.AdjList.get(u)) {\r\n                if (this.col.get(v) == State_1.State.white) {\r\n                    this.col.set(v, State_1.State.grey);\r\n                    this.pi.set(v, u);\r\n                    this.bfs_animation.push(this.getGraphD3());\r\n                    Q.push(v);\r\n                }\r\n            }\r\n            Q.shift();\r\n            this.col.set(u, State_1.State.black);\r\n            this.bfs_animation.push(this.getGraphD3());\r\n        }\r\n    }\r\n    /**\r\n     * Nach der Breitensuche findet diese Funktion den kürzesten Weg von Start zu Ende\r\n     * über die Elternknoten.\r\n     * @param start Startknoten\r\n     * @param end Endknoten\r\n     * @returns Array<string> mit Pfad von Start zu Ende\r\n     */\r\n    find_path(start, end) {\r\n        var result = [end];\r\n        var next = this.pi.get(end);\r\n        while (next != null) {\r\n            result.push(next);\r\n            next = this.pi.get(next);\r\n        }\r\n        result = result.reverse();\r\n        return result;\r\n    }\r\n    /**\r\n     * Diese Funktion verändert die Adjazenzliste so, dass bei DFS immer der kürzeste Weg vom\r\n     * Startknoten zum Zielknoten gewählt wird.\r\n     * @param path Array<string>: Kürzester Weg vom Startknoten zu Endknoten\r\n     */\r\n    modify_adjacency_list(path) {\r\n        for (let i = 0; i < path.length - 1; i++) {\r\n            var neighbours = this.AdjList.get(path[i]);\r\n            if (neighbours && neighbours[0] != path[i + 1]) {\r\n                // Finde index des nächsten Knotens\r\n                const index = neighbours.findIndex((x) => x === path[i + 1]);\r\n                // Tausche mit erster Stelle\r\n                const b = neighbours[0];\r\n                neighbours[0] = neighbours[index];\r\n                neighbours[index] = b;\r\n                // Aktualisiere Adajenzliste\r\n                this.AdjList.set(path[i], neighbours);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     * Diese Methode initialisiert und ruft die rekursive Tiefensuche auf.\r\n     * Als Ergebnis fallen Low-Werte, Entdeck-, Abschlusszeit und Elternliste an.\r\n     * @param start Startknoten, vom dem gesucht wird\r\n     */\r\n    dfs(start) {\r\n        // 1. Initialisierung\r\n        for (var u of this.AdjList.keys()) {\r\n            this.col.set(u, State_1.State.white);\r\n            this.pi.set(u, null);\r\n        }\r\n        this.time = 0;\r\n        // Beginne beim Startknoten\r\n        this.mdfs_visit(start);\r\n        // 2. Hauptschleife (bei zusammenhängenden Graphen passier hier nichts)\r\n        for (var u of this.AdjList.keys()) {\r\n            if (this.col.get(u) == State_1.State.white)\r\n                this.mdfs_visit(u);\r\n        }\r\n    }\r\n    /**\r\n     * Diese Methode implementiert den Algorithmus von S.78 des Skripts.\r\n     * Der Graph wird mittels DFS rekursiv traversiert. Der Low-Wert wird u.a. berechnet.\r\n     * @param u Knoten, der besucht wird\r\n     * @returns\r\n     */\r\n    mdfs_visit(u) {\r\n        // entdecke u\r\n        this.col.set(u, State_1.State.grey);\r\n        this.d.set(u, this.time);\r\n        this.l.set(u, this.d.get(u));\r\n        this.time += 1;\r\n        // Bearbeitung von u\r\n        var neighbours = this.AdjList.get(u);\r\n        if (neighbours == undefined)\r\n            return;\r\n        for (var v of neighbours) {\r\n            if (this.col.get(v) == State_1.State.white) {\r\n                this.pi.set(v, u);\r\n                this.mdfs_visit(v);\r\n                // Kleinern Low-Wert des Kindes übernehmen\r\n                this.l.set(u, Math.min(this.l.get(u), this.l.get(v)));\r\n            }\r\n            // Rückwärtskante\r\n            if (this.col.get(v) == State_1.State.grey && this.pi.get(u) != v)\r\n                // Merken, welche am, weitesten zurück reicht\r\n                this.l.set(u, Math.min(this.l.get(u), this.d.get(v)));\r\n        }\r\n        this.col.set(u, State_1.State.black);\r\n        this.f.set(u, this.time);\r\n        this.time += 1;\r\n    }\r\n    /**\r\n     * Findet alle zweifachen Zusammenhangskomponenten in einem beliebigen Graph.\r\n     * @param start Startknoten, vom dem aus gesucht wird\r\n     */\r\n    zweifache_Komponenten(start) {\r\n        // Tiefensuche für L-Werte bereits gelaufen\r\n        // 1. Initialisierung\r\n        for (const v of this.AdjList.keys()) {\r\n            this.col.set(v, State_1.State.white);\r\n        }\r\n        // Keller ist bereits als leere Liste initialisiert\r\n        // this.keller = [];\r\n        // Beginne beim Startknoten (dieselbe Reihenfolge wie bei 1.)\r\n        this.ndfs_visit(start);\r\n        for (const v of this.AdjList.keys()) {\r\n            if (this.col.get(v) == State_1.State.white) {\r\n                this.ndfs_visit(v);\r\n                // Kann bei isolierten Knoten passieren\r\n                if (this.keller.length != 0) {\r\n                    // Knote in Q(?) ausgeben\r\n                    this.keller = [];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Hilfsfunktion für zweichfache_Komponenten(start). Rekursive Suche nach Komponenten.\r\n     * @param u derzeitige Knoten\r\n     */\r\n    ndfs_visit(u) {\r\n        this.col.set(u, State_1.State.grey);\r\n        for (const v of this.AdjList.get(u)) {\r\n            if (this.col.get(v) == State_1.State.white) {\r\n                this.keller.push(v);\r\n                this.ndfs_visit(v);\r\n                if (this.l.get(v) >= this.d.get(u)) {\r\n                    // Solange Knoten von S entfernen und Ausgeben, bis v ausgegeben. Knoten u auch mit ausgeben;\r\n                    var component = [this.keller.pop()];\r\n                    while (component[component.length - 1] !== v) {\r\n                        component.push(this.keller.pop());\r\n                    }\r\n                    component.push(u);\r\n                    this.components.push(component);\r\n                }\r\n            }\r\n        }\r\n        this.col.set(u, State_1.State.black);\r\n    }\r\n    /**\r\n     * Diese Methode findet Rückwärtskanten (inkl Start- und Endpunkt) und fügt diese this.back_edges hinzu.\r\n     * @param u Knoten in Bearbeitung\r\n     * @param start Startknoten\r\n     * @param end Zielknoten\r\n     * @returns Nothing\r\n     */\r\n    find_back_edges(u, start, end) {\r\n        // Derzeitiger Knoten ist zum 2. Mal am Start (Ende)\r\n        if (u == start && this.col.get(u) == State_1.State.grey) {\r\n            this.back_edges.push(this.edge);\r\n            this.edge = [];\r\n            this.done = false;\r\n            return;\r\n        }\r\n        // entdecke u\r\n        this.col.set(u, State_1.State.grey);\r\n        // Bearbeitung von u\r\n        var neighbours = this.AdjList.get(u);\r\n        if (neighbours == undefined)\r\n            return;\r\n        // Wenn das Ende bereits entdeckt ist ...\r\n        if (this.col.get(end) == State_1.State.grey) {\r\n            // Knoten mit niedrigstem Low-Wert folgen\r\n            var next = neighbours[0];\r\n            for (const neighbour of neighbours) {\r\n                if (this.pi.get(u) == next ||\r\n                    (this.l.get(next) > this.l.get(neighbour) &&\r\n                        this.pi.get(u) != neighbour))\r\n                    next = neighbour;\r\n            }\r\n            // Wenn Vorgänger ausgewählt wurde gibt es keine Nachfolger -> keine Rückwärtskanten\r\n            if (next == this.pi.get(u))\r\n                return;\r\n            // Ist nächster Knoten grau? -> (Rückwertkante)\r\n            if (this.col.get(next) == State_1.State.grey) {\r\n                // Hauptpfad -> nächste Rückwärtskante suchen\r\n                if (!this.done) {\r\n                    this.done = true;\r\n                }\r\n                else {\r\n                    this.back_edges.push(this.edge);\r\n                    this.edge = [];\r\n                    this.done = false;\r\n                }\r\n                this.edge.push(next);\r\n            }\r\n            else {\r\n                // Nebenpfad -> Rückwärtskante weiter verfolgen\r\n                this.edge.push(next);\r\n            }\r\n            this.find_back_edges(next, start, end);\r\n            //Ende noch nicht entdeckt (suche Ende)\r\n        }\r\n        else {\r\n            // nächsten Knoten auf Hauptpfad aufrufen (Adjazenzliste ist sortiert)\r\n            if (neighbours[0] == end) {\r\n                this.edge.push(end);\r\n            }\r\n            this.find_back_edges(neighbours[0], start, end);\r\n        }\r\n    }\r\n    /**\r\n     * Diese Methode erstellt einen Kreis auf den gefundenen Rückwärtskanten und\r\n     * fügt alle Knoten auf diesem Kreis this.circle hinzu.\r\n     * @param start Startknoten\r\n     * @param end Endknoten\r\n     */\r\n    create_circle(start, end) {\r\n        // Alle Knoten weiß setzen\r\n        for (var u of this.AdjList.keys()) {\r\n            this.col.set(u, State_1.State.white);\r\n        }\r\n        this.circle_animation.push(this.getGraphD3());\r\n        // Rückwärtskanten finden\r\n        this.find_back_edges(start, start, end);\r\n        // this.circle_animation.push(this.getGraphD3());\r\n        // Graph ohne Rückwärtskanten, kann keinen Kreis bilden\r\n        if (this.back_edges.length < 1) {\r\n            this.circle = [];\r\n            return;\r\n        }\r\n        // zwei miteinander verbundene Knoten sind zweifach zusammenhängend, aber haben keinen ungerichteten Kreis\r\n        if (Array.from(this.AdjList.keys()).length < 3) {\r\n            this.circle = [];\r\n            return;\r\n        }\r\n        // Startknoten behandeln und zu Kreis hinzufügen\r\n        var next = start;\r\n        this.circle.push(next);\r\n        this.circle_animation.push(this.getGraphD3());\r\n        // Startknoten der Rückwärtskanten\r\n        var start_nodes = this.back_edges.map((back_edges) => back_edges[back_edges.length - 1]);\r\n        // Finde Ende\r\n        while (next != end) {\r\n            const index = start_nodes.indexOf(next);\r\n            // Wenn es eine Rückwärtskante gibt, die noch nicht besucht wurde ...\r\n            if (index >= 0 &&\r\n                this.col.get(next) != State_1.State.black &&\r\n                this.col.get(this.back_edges[index][0]) != State_1.State.black) {\r\n                next = this.back_edges[index][0];\r\n                // Kante auf Hauptpfad schwarz färben\r\n                this.col.set(next, State_1.State.black);\r\n                // Nehme Rückwärtskante (Richtung Ende) und füge alle Knoten dem Kreis hinzu\r\n                const back_edges = this.circle.push(...this.back_edges[index]\r\n                    .reverse()\r\n                    .slice(1, this.back_edges[index].length));\r\n                for (const v of this.back_edges[index])\r\n                    this.col.set(v, State_1.State.circle);\r\n                this.circle_animation.push(this.getGraphD3());\r\n                // Lösche Rückwärtskante\r\n                this.back_edges[index] = [];\r\n                // Wenn es keine Rückwärtskante gibt\r\n            }\r\n            else {\r\n                // Gehe Richtung Ende (nach unten) auf dem Hauptpfad\r\n                next = this.AdjList.get(next)[0];\r\n                this.circle.push(next);\r\n                this.col.set(next, State_1.State.circle);\r\n                this.circle_animation.push(this.getGraphD3());\r\n            }\r\n        }\r\n        // Endknoten der Rückwärtskanten\r\n        var end_nodes = this.back_edges.map((back_edges) => back_edges[0]);\r\n        // Finde Start\r\n        while (next != start) {\r\n            const index = end_nodes.indexOf(next);\r\n            // Wenn es eine Rückwärtskante gibt, die noch nicht besucht wurde ...\r\n            if (index >= 0 &&\r\n                this.col.get(next) != State_1.State.black &&\r\n                this.col.get(this.back_edges[index][this.back_edges[index].length - 1]) != State_1.State.black) {\r\n                // Nehme Rückwärtskante (Richtung Start) und füge alle Knoten dem Kreis hinzu\r\n                next = this.back_edges[index][this.back_edges[index].length - 1];\r\n                this.circle.push(...this.back_edges[index].slice(1, this.back_edges[index].length));\r\n                for (const v of this.back_edges[index])\r\n                    this.col.set(v, State_1.State.circle);\r\n                this.circle_animation.push(this.getGraphD3());\r\n                // Wenn es keine Rückwärtskante gibt\r\n            }\r\n            else {\r\n                // Gehe Richtung Start (nach oben) auf dem Hauptpfad\r\n                next = this.pi.get(next);\r\n                this.circle.push(next);\r\n                this.col.set(next, State_1.State.circle);\r\n                this.circle_animation.push(this.getGraphD3());\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.Graph = Graph;\r\n\n\n//# sourceURL=webpack:///./src/Graph.ts?");

/***/ }),

/***/ "./src/State.ts":
/*!**********************!*\
  !*** ./src/State.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.State = void 0;\r\nexports.State = {\r\n    grey: \"orange\",\r\n    white: \"green\",\r\n    black: \"red\",\r\n    circle: \"blue\"\r\n};\r\n\n\n//# sourceURL=webpack:///./src/State.ts?");

/***/ }),

/***/ "./src/draw_graph/create_graph.js":
/*!****************************************!*\
  !*** ./src/draw_graph/create_graph.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Graph_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Graph.ts */ \"./src/Graph.ts\");\n\r\n\r\nvar g = new _Graph_ts__WEBPACK_IMPORTED_MODULE_0__.Graph();\r\n\r\nvar vertices = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"U\", \"V\"];\r\n\r\n// Knoten hinzufügen\r\nfor (var i = 0; i < vertices.length; i++) {\r\n  g.addVertex(vertices[i]);\r\n}\r\n\r\n// Kanten hinzufügen\r\ng.addEdge(\"U\", \"A\");\r\ng.addEdge(\"U\", \"J\");\r\ng.addEdge(\"A\", \"B\");\r\ng.addEdge(\"B\", \"C\");\r\ng.addEdge(\"I\", \"J\");\r\ng.addEdge(\"C\", \"D\");\r\ng.addEdge(\"E\", \"I\");\r\ng.addEdge(\"E\", \"A\");\r\ng.addEdge(\"D\", \"F\");\r\ng.addEdge(\"E\", \"G\");\r\ng.addEdge(\"E\", \"V\");\r\ng.addEdge(\"V\", \"F\");\r\ng.addEdge(\"V\", \"H\");\r\ng.addEdge(\"F\", \"H\");\r\ng.addEdge(\"F\", \"G\");\r\n\r\n// Start- und Endwerte definieren\r\nvar start = \"U\";\r\nvar end = \"V\";\r\n\r\n// Kürzesten Weg von Start zu Ziel finden mit Breitensuche\r\ng.bfs(start);\r\ng.modify_adjacency_list(g.find_path(start, end));\r\n\r\n// Tiefensuche mit Low-Werten\r\ng.dfs(start);\r\n\r\n// Zwei-fache Komponenten finden\r\ng.zweifache_Komponenten(start);\r\n\r\nconsole.log(g.components);\r\n\r\ng.create_circle(start, end);\r\nconsole.log(g.circle);\r\n\r\n//intialize data\r\nvar graph = g.getGraphD3();\r\n\r\n//initilize svg or grab svg\r\nvar svg = d3.select(\"svg\");\r\nvar width = svg.attr(\"width\");\r\nvar height = svg.attr(\"height\");\r\n\r\n// Slider\r\nvar xRangeSlider = document.getElementById(\"mySlider\");\r\nxRangeSlider.min = 0;\r\nxRangeSlider.max = g.circle_animation.length - 1;\r\nxRangeSlider.value = 0;\r\n\r\nvar simulation = d3\r\n  .forceSimulation(graph.nodes)\r\n  .force(\r\n    \"link\",\r\n    d3\r\n      .forceLink()\r\n      .id((d) => d.name)\r\n      .links(graph.links)\r\n  )\r\n  .force(\"charge\", d3.forceManyBody().strength(-300))\r\n  .force(\"center\", d3.forceCenter(width / 2, height / 2))\r\n  .on(\"tick\", ticked);\r\n\r\nvar links = svg\r\n  .append(\"g\")\r\n  .attr(\"class\", \"links\")\r\n  .selectAll(\"line\")\r\n  .data(graph.links)\r\n  .enter()\r\n  .append(\"line\")\r\n  .attr(\"stroke-width\", function (d) {\r\n    return 3;\r\n  })\r\n  .style(\"stroke\", (d) => d.color);\r\n\r\nvar drag = d3\r\n  .drag()\r\n  .on(\"start\", dragstarted)\r\n  .on(\"drag\", dragged)\r\n  .on(\"end\", dragended);\r\n\r\nvar textsAndNodes = svg\r\n  .append(\"g\")\r\n  .selectAll(\"g\")\r\n  .data(graph.nodes)\r\n  .enter()\r\n  .append(\"g\")\r\n  .call(drag);\r\n\r\nvar cirlces = textsAndNodes\r\n  .data(graph.nodes)\r\n  .append(\"circle\")\r\n  .attr(\"r\", 5)\r\n  .style(\"fill\", (d) => d.color);\r\nvar texts = textsAndNodes\r\n  .append(\"text\")\r\n  .attr(\"x\", 6)\r\n  .attr(\"y\", 3)\r\n  .text((d) => d.name);\r\n\r\nvar slider = d3.select(\"#mySlider\").on(\"change\", (d) => {\r\n  update(xRangeSlider.value);\r\n});\r\n\r\nfunction update(selectedValue) {\r\n  graph = g.circle_animation[selectedValue];\r\n  console.log(graph.links);\r\n  // recolors circles\r\n  svg\r\n    .selectAll(\"circle\")\r\n    .data(graph.nodes)\r\n    .style(\"fill\", (d) => d.color);\r\n\r\n  // keep force on links\r\n  simulation = simulation\r\n    .force(\r\n      \"link\",\r\n      d3\r\n        .forceLink()\r\n        .id((d) => d.name)\r\n        .links(graph.links)\r\n    )\r\n    .force(\"charge\", d3.forceManyBody().strength(-300))\r\n    .force(\"center\", d3.forceCenter(width / 2, height / 2))\r\n    .on(\"tick\", ticked);\r\n    \r\n  // recolor edges\r\n  svg\r\n    .selectAll(\"line\")\r\n    .data(graph.links)\r\n    .style(\"stroke\", (d) => d.color);\r\n}\r\n\r\nfunction ticked() {\r\n  // translate (x, y)\r\n  textsAndNodes.attr(\"transform\", (d) => \"translate(\" + d.x + \", \" + d.y + \")\");\r\n\r\n  links\r\n    .attr(\"x1\", function (d) {\r\n      return d.source.x;\r\n    })\r\n    .attr(\"y1\", function (d) {\r\n      return d.source.y;\r\n    })\r\n    .attr(\"x2\", function (d) {\r\n      return d.target.x;\r\n    })\r\n    .attr(\"y2\", function (d) {\r\n      return d.target.y;\r\n    });\r\n}\r\n\r\nfunction dragstarted(d) {\r\n  if (!d3.event.active) simulation.alphaTarget(0.3).restart();\r\n  d.fx = d.x;\r\n  d.fy = d.y;\r\n}\r\n\r\nfunction dragged(d) {\r\n  d.fx = d3.event.x;\r\n  d.fy = d3.event.y;\r\n}\r\n\r\nfunction dragended(d) {\r\n  if (!d3.event.active) simulation.alphaTarget(0);\r\n  d.fx = null;\r\n  d.fy = null;\r\n}\r\n\n\n//# sourceURL=webpack:///./src/draw_graph/create_graph.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/draw_graph/create_graph.js");
/******/ 	
/******/ })()
;